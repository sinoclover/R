fit$coefficients
fit$coefficients[2]
coef(fit)
#
# 附加样条
ns1 <- multinom(choice ~ ns(l, df=4)+ns(a, df=4)+ns(b, df=4) , data = rawdata)
print(ns1)
#
# 附加样条
ns1 <- multinom(choice ~ ns(l, df=4, intercept=TRUE)+ns(a, df=4, intercept=TRUE)+ns(b, df=4, intercept=TRUE) , data = rawdata)
print(ns1)
require(splines)
X <- c(1,2,3)
print(X)
test <- ns(X, df=4, intercept=TRUE)
print(test)
print(ns1)
u2 <- predict(ns1, newdata)
print(u2)
print(rawdata)
f <- multinom(y ~ l + a + b)
coef(fit)
print(newdata)
coef(fit)
print(newdata)
u <- coef(fit)[0] + coef(fit)[1] * newdata$l + coef(fit)[2] * newdata$a + coef(fit)[3] * newdata$b
print(u)
xx = coef(fit)[1]
print(xx)
nbb = xx * seq(1, 10, 1)
print(nbb)
print(newdata$l)
newdata <- expand.grid(l = 10, a = seq(-100, 100, 5), b = seq(-100, 100, 5))
print(newdata)
xx = coef(fit)[1]
print(xx)
nbb = xx * seq(1, 10, 1)
print(nbb)
print(newdata$l)
print(newdata)
nbb = coef(fit)[1] * seq(1, 10, 1)
print(nbb)
print(newdata$l)
u <- coef(fit)[0] + coef(fit)[1] * newdata$l + coef(fit)[2] * newdata$a + coef(fit)[3] * newdata$b
print(u)
u = coef(fit)[0] + coef(fit)[1] * newdata$l + coef(fit)[2] * newdata$a + coef(fit)[3] * newdata$b
print(u)
nbb = coef(fit)[1] * newdata$l
print(nbb)
u = coef(fit)[1] * newdata$l + coef(fit)[2] * newdata$a + coef(fit)[3] * newdata$b
print(u)
u = coef(fit)[0] + (coef(fit)[1] * newdata$l + coef(fit)[2] * newdata$a + coef(fit)[3] * newdata$b)
print(u)
coe = c(1,2,3)
class(coe)
coe = seq(1,2,3)
class(coe)
coe = vector(1,2,3)
coe = seq(coef(fit))
print(coe)
coe = seq(coef(fit)[0])
print(coe)
coe = coef(fit)[0]
print(coe)
coe <- coef(fit)[0]
print(coe)
coef(fit)[0]
fit <- multinom(choice ~ l + a + b, data = rawdata)
coef(fit)
coe <- seq(coef(fit))
print(coe)
coe <- seq(coef(fit)[0])
print(coe)
coef(fit)[0]
nbb = coef(fit)[1] * newdata$l
print(nbb)
coef(fit)[1]
u = coef(fit)[1] + (coef(fit)[2] * newdata$l + coef(fit)[3] * newdata$a + coef(fit)[4] * newdata$b)
print(u)
u = coef(fit)[1] + coef(fit)[2] * newdata$l + coef(fit)[3] * newdata$a + coef(fit)[4] * newdata$b
print(u)
newdata <- expand.grid(l = 10, a = seq(-100, 100, 5), b = seq(-100, 100, 5))
print(newdata)
coef(fit)
u = coef(fit)[2] * newdata$l + coef(fit)[3] * newdata$a + coef(fit)[4] * newdata$b
print(u)
coef(fit)[1]
coef(fit)[2]
u = coef(fit)[2] * 10 + coef(fit)[3] * (-100) + coef(fit)[4] * (-100)
print(u)
coef(fit)
xxx = -0.0001748286 * 10 + 0.0116847265 * (-100) + 0.0162697489 * (-100)
print(xxx)
u = coef(fit)[2] * 10 + coef(fit)[3] * (-100) + coef(fit)[4] * (-100)
print(u)
u = coef(fit)[2] * newdata$l + coef(fit)[3] * newdata$a + coef(fit)[4] * newdata$b
print(u)
class(u)
class(newdata)
u <- data.frame(u)
class(u)
print(u)
uu <- coef(fit) * newdata
print(uu)
c <- data.frame(coef(fit))
print(c)
c <- data.frame(coef(fit)[1], coef(fit)[2], coef(fit)[3])
print(c)
c <- data.frame(coef(fit)[2], coef(fit)[3], coef(fit)[4])
print(c)
uu <- c * newdata
class(c)
u <- data.frame(u)
# 导入线性回归数据集
lmdata <- read.csv('F://Coding/R/MNL/data/demolm.csv')
# 添加新数据
newdata <- expand.grid(l = 10, a = seq(-100, 100, 5), b = seq(-100, 100, 5))
print(newdata)
# 计算效用值
u <- coef(fit)[2] * newdata$l + coef(fit)[3] * newdata$a + coef(fit)[4] * newdata$b
u <- data.frame(u)
print(u)
u <- data.frame(u)
print(u)
x <- unique(newdata$a)
y <- unique(newdata$b)
z <- matrix(u, nrow = length(y), ncol = length(x))
plot3d(newdata$a, newdata$b, u, type="s", size=0.5, lit=FALSE,xlab = "a",ylab="b",zlab = "utility")
surface3d(x,y,z,alpha=0.4, front="lines", back="lines")
require(rgl)
library(rgl)
plot3d(newdata$a, newdata$b, u, type="s", size=0.5, lit=FALSE,xlab = "a",ylab="b",zlab = "utility")
surface3d(x,y,z,alpha=0.4, front="lines", back="lines")
x <- unique(newdata$a)
y <- unique(newdata$b)
z <- matrix(u, nrow = length(y), ncol = length(x))
plot3d(newdata$a, newdata$b, u, type="s", size=0.5, lit=FALSE,xlab = "a",ylab="b",zlab = "utility")
surface3d(x,y,z,alpha=0.4, front="lines", back="lines")
movie3d(spin3d(axis=c(0,0,1),rpm=3),duration=10,fps=50)
library(magick)
movie3d(spin3d(axis=c(0,0,1),rpm=3),duration=10,fps=50)
x <- unique(newdata$a)
y <- unique(newdata$b)
z <- matrix(u, nrow = length(y), ncol = length(x))
plot3d(newdata$a, newdata$b, u, type="s", size=0.5, lit=FALSE,xlab = "a",ylab="b",zlab = "utility")
surface3d(x,y,z,alpha=0.4, front="lines", back="lines")
x <- unique(newdata$a)
y <- unique(newdata$b)
z <- matrix(u, nrow = length(y), ncol = length(x))
plot3d(newdata$a, newdata$b, u, type="s", size=0.5, lit=FALSE,xlab = "a",ylab="b",zlab = "utility")
surface3d(x,y,z,alpha=0.4, front="lines", back="lines")
movie3d(spin3d(axis=c(0,0,1),rpm=3),duration=10,fps=50)
print(u)
x <- newdata$a
y <- newdata$b
z <- u
persp(x, y, z, theta = 30, phi = 30,
expand = 0.5, col = drapecol(z))
#
# 附加样条
ns1 <- multinom(choice ~ ns(l, df=4, intercept=TRUE)+ns(a, df=4, intercept=TRUE)+ns(b, df=4, intercept=TRUE) , data = rawdata)
print(ns1)
print(test)
class(test)
test[1]
test[2]
test$1
test.1
test[4]
test[1][1]
test[2][1]
test[2][2]
test <- data.frame(test)
print(test)
require(splines)
X <- c(4,2,3)
print(X)
test <- ns(X, df=4, intercept=TRUE)
print(test)
test <- data.frame(test)
print(test)
require(splines)
X <- c(4,80,3)
print(X)
test <- ns(X, df=4, intercept=TRUE)
print(test)
coef(ns1)
# 结合系数利用上述新数据对样条计算效用值
ns1l <- ns(newdata$l, df=4, intercept = TRUE)
# 结合系数利用上述新数据对样条计算效用值
ns1l <- ns(newdata$a, df=4, intercept = TRUE)
ns1l <- data.frame(ns1l)
print(ns1l)
require(splines)
X <- c(80,80,80,80)
print(X)
test <- ns(X, df=4, intercept=TRUE)
predict(ns1, newdata)
predict(ns1, newdata).values
# 添加新数据
newdata <- expand.grid(l = seq(0, 100, 10), a = seq(-100, 100, 10), b = seq(-100, 100, 10))
print(newdata)
# 添加新数据
newdata <- expand.grid(l = seq(0, 100, 10), a = seq(-100, 100, 20), b = seq(-100, 100, 20))
print(newdata)
# 计算效用值
u <- coef(fit)[2] * newdata$l + coef(fit)[3] * newdata$a + coef(fit)[4] * newdata$b
u <- data.frame(u)
print(u)
test <- ns(X, df=4, intercept=TRUE)
require(splines)
X <- c(4,80,3)
print(X)
test <- ns(X, df=4, intercept=TRUE)
print(test)
require(splines)
test <- data.frame(test)
print(test)
# 附加样条
ns1 <- multinom(choice ~ ns(l, df=4, intercept=TRUE)+ns(a, df=4, intercept=TRUE)+ns(b, df=4, intercept=TRUE) , data = rawdata)
print(ns1)
coef(ns1)
coef(ns1)[1]
coef(ns1)[13]
coef(ns1)[2]
print(ns1l)
ns1a <- ns(newdata$a, df=4, intercept = TRUE)
ns1a <- data.frame(ns1a)
print(ns1a)
ns1b <- ns(newdata$b, df=4, intercept = TRUE)
ns1b <- data.frame(ns1b)
print(ns1b)
print(u1)
print(ul)
# 结合系数利用上述新数据对样条计算效用值
ns1l <- ns(newdata$l, df=4, intercept = TRUE)
ns1l <- data.frame(ns1l)
print(ns1l)
ul = coef(ns1)[2] * ns1l$X1 + coef(ns1)[3] * ns1l$X2 + coef(ns1)[4] * ns1l$X3 + coef(ns1)[5] * ns1l$X4
print(ul)
# 结合系数利用上述新数据对样条计算效用值
ns1l <- ns(newdata$l, df=4, intercept = TRUE)
ns1l <- data.frame(ns1l)
print(ns1l)
ul = coef(ns1)[2] * ns1l$X1 + coef(ns1)[3] * ns1l$X2 + coef(ns1)[4] * ns1l$X3 + coef(ns1)[5] * ns1l$X4
print(ul)
ns1a <- ns(newdata$a, df=4, intercept = TRUE)
ns1a <- data.frame(ns1a)
print(ns1a)
ua = coef(ns1)[6] * ns1a$X1 + coef(ns1)[7] * ns1a$X2 + coef(ns1)[8] * ns1a$X3 + coef(ns1)[9] * ns1a$X4
print(ua)
ns1b <- ns(newdata$b, df=4, intercept = TRUE)
ns1b <- data.frame(ns1b)
print(ns1b)
ub = coef(ns1)[10] * ns1b$X1 + coef(ns1)[11] * ns1b$X2 + coef(ns1)[12] * ns1b$X3 + coef(ns1)[13] * ns1b$X4
print(ub)
u_ns = ul + ua + ub
print(u_ns)
print(u)
print(u_ns)
predict(ns1, newdata)
u_ns = ul + ua + ub
u_ns = data.frame(u_ns)
print(u_ns)
print(u)
# 直接使用multinom进行多项logit回归分析
# 其实mlogit和multinom要求的数据格式一致，也类似于pylogit要求的格式。
# 而mlogit进行数据重塑前的数据反而较为复杂。
library(nnet)
library(splines)
library(rgl)
# 导入常规数据集
rawdata <- read.csv('F://Coding/R/MNL/data/demoR.csv')
print(rawdata)
# 导入线性回归数据集，使用原数据的色彩值进行效用验证
lmdata <- read.csv('F://Coding/R/MNL/data/demolm.csv')
print(lmdata)
u_exam <- coef(fit)[2] * lmdata$l + coef(fit)[3] * lmdata$a + coef(fit)[4] * lmdata$b
print(u_exam)
fit <- multinom(choice ~ l + a + b, data = rawdata)
print(fit)
print(u_exam)
print(exp(u_exam))
u_exam <- coef(fit)[2] * lmdata$l + coef(fit)[3] * lmdata$a + coef(fit)[4] * lmdata$b + coef(fit)[1]
print(exp(u_exam))
# 导入常规数据集
rawdata <- read.csv('F://Coding/R/MNL/data/demoR.csv')
print(rawdata)
fit <- multinom(choice ~ l + a + b, data = rawdata)
print(fit)
coef(fit)
# 导入线性回归数据集，使用原数据的色彩值进行效用验证
lmdata <- read.csv('F://Coding/R/MNL/data/demolm.csv')
print(lmdata)
u_exam <- coef(fit)[2] * lmdata$l + coef(fit)[3] * lmdata$a + coef(fit)[4] * lmdata$b + coef(fit)[1]
print(exp(u_exam))
u_exam <- coef(fit)[2] * lmdata$l + coef(fit)[3] * lmdata$a + coef(fit)[4] * lmdata$b + coef(fit)[1]
print(u_exam)
require(foreign)
require(nnet)
require(ggplot2)
require(reshape2)
ml <- read.dta("F://Coding/R/MNL/data/hsbdemo.dta")
print(ml)
examdata <- read.csv('F://Coding/R/MNL/data/lmexam.csv')
print(examdata)
examdata <- read.csv('F://Coding/R/MNL/data/lmexam.csv')
print(examdata)
print(examdata)
examdata$choice2 <- relevel(examdata$choice, ref = 'E')
exam <- multinom(choice2 ~ l + a + b, data = examdata)
summary(exam)
examdata$choice2 <- relevel(examdata$choice, ref = 'E')
print(examdata)
exam <- multinom(choice ~ l + a + b, data = examdata)
summary(exam)
exam <- multinom(choice ~ l + a + b |0|0, data = examdata)
summary(exam)
print(examdata)
u_exam <- coef(fit)[2] * lmdata$l + coef(fit)[3] * lmdata$a + coef(fit)[4] * lmdata$b + coef(fit)[1]
print(u_exam)
# 转换为概率值
pr <- exp(u_exam)
print(pr)
print(sum(pr))
# 归一化处理
pr <- pr / sum(pr)
print(pr)
# 2.1 创新点，利用偏好影响值计算各色彩方案概率，通过线性回归反推相关色彩属性变量系数，从而进行整个色彩空间的预测。
# 直接通过对概率进行LOGIT，然后对原色彩数据进行线性回归，选择最后一项最为基准参考。
fit_lm <- lm(logit_value ~ dl + da + db, data = lmdata)
print(fit_lm)
coef(fit_lm)
print(fit)
# 通过色彩数据计算效用值进行验证
u_examlm <- coef(fit_lm)[2] * lmdata$l + coef(fit_lm)[3] * lmdata$a + coef(fit_lm)[4] * lmdata$b + coef(fit_lm)[1]
print(u_examlm)
# 转换为概率值
pr_lm <- exp(u_examlm)
print(pr_lm)
# 对概率进行归一化处理
pr_lm <- pr_lm / sum(pr_lm)
print(pr_lm)
# 3.2根据上述回归系数进行基于原数据的概率验证
# 记录各个样条基函数
ns1l <- ns(l, df=4, intercept = TRUE)
# 3.1对于1.1进行样条基展开，并进行多项logit回归以观测方案属性变量的非线性性
ns1 <- multinom(choice ~ ns(l, df=4, intercept=TRUE)+ns(a, df=4, intercept=TRUE)+ns(b, df=4, intercept=TRUE) , data = rawdata)
print(ns1)
coef(ns1)
# 3.2根据上述回归系数进行基于原数据的概率验证
# 记录各个样条基函数
ns1l <- ns(l, df=4, intercept = TRUE)
# 3.2根据上述回归系数进行基于原数据的概率验证
# 记录各个样条基函数
ns1l <- ns(rawdata$l, df=4, intercept = TRUE)
ns1l <- data.frame(ns1l)
print(ns1l)
# 3.2根据上述回归系数进行基于原数据的概率验证
# 记录各个样条基函数并计算各效用值
ns1l <- ns(rawdata$l, df=4, intercept = TRUE)
ns1l <- data.frame(ns1l)
ul = coef(ns1)[2] * ns1l$X1 + coef(ns1)[3] * ns1l$X2 + coef(ns1)[4] * ns1l$X3 + coef(ns1)[5] * ns1l$X4
ns1a <- ns(rawdata$a, df=4, intercept = TRUE)
ns1a <- data.frame(ns1a)
ua = coef(ns1)[6] * ns1a$X1 + coef(ns1)[7] * ns1a$X2 + coef(ns1)[8] * ns1a$X3 + coef(ns1)[9] * ns1a$X4
ns1b <- ns(rawdata$b, df=4, intercept = TRUE)
ns1b <- data.frame(ns1b)
ub = coef(ns1)[10] * ns1b$X1 + coef(ns1)[11] * ns1b$X2 + coef(ns1)[12] * ns1b$X3 + coef(ns1)[13] * ns1b$X4
u_ns = ul + ua + ub + coef(ns1)[1]
print(u_ns)
# 3.2根据上述回归系数进行基于原数据的概率验证
# 记录各个样条基函数并计算各效用值
ns1l <- ns(rawdata$l, df=4, intercept = TRUE)
print(ns1l)
# 3.2根据上述回归系数进行基于原数据的概率验证
# 记录各个样条基函数并计算各效用值
ns1l <- ns(lmdata$l, df=4, intercept = TRUE)
print(ns1l)
# 3.2根据上述回归系数进行基于原数据的概率验证
# 记录各个样条基函数并计算各效用值
ns1l <- ns(lmdata$l, df=4, intercept = TRUE)
print(ns1l)
ns1l <- data.frame(ns1l)
ul = coef(ns1)[2] * ns1l$X1 + coef(ns1)[3] * ns1l$X2 + coef(ns1)[4] * ns1l$X3 + coef(ns1)[5] * ns1l$X4
ns1a <- ns(lmdata$a, df=4, intercept = TRUE)
ns1a <- data.frame(ns1a)
ua = coef(ns1)[6] * ns1a$X1 + coef(ns1)[7] * ns1a$X2 + coef(ns1)[8] * ns1a$X3 + coef(ns1)[9] * ns1a$X4
ns1b <- ns(lmdata$b, df=4, intercept = TRUE)
ns1b <- data.frame(ns1b)
ub = coef(ns1)[10] * ns1b$X1 + coef(ns1)[11] * ns1b$X2 + coef(ns1)[12] * ns1b$X3 + coef(ns1)[13] * ns1b$X4
u_ns = ul + ua + ub + coef(ns1)[1]
print(u_ns)
# 计算总效用值
u_ns = ul + ua + ub + coef(ns1)[1]
print(u_ns)
# 转换为概率值
pr_ns <- exp(u_ns)
print(pr_ns)
# 对概率进行归一化处理
pr_ns <- pr_ns / sum(pr_ns)
print(pr_ns)
print(lmdata)
print(testdata)
testdata <- read.csv('F:/Coding/R/MNL/data/pcatest.csv')
print(testdata)
pr <- princomp(testdata, cor=TRUE)
summary(pr, loadings=TRUE
summary(pr, loadings=TRUE)
pr <- princomp(testdata, cor=TRUE)
summary(pr, loadings=TRUE)
pr <- princomp(testdata, cor=TRUE, scores = TRUE)
summary(pr, loadings=TRUE)
# 直接使用multinom进行多项logit回归分析
# 其实mlogit和multinom要求的数据格式一致，也类似于pylogit要求的格式。
# 而mlogit进行数据重塑前的数据反而较为复杂。
library(nnet)
library(splines)
# 1.1利用multinom进行基于相应的数据格式进行多项logit回归
# 导入常规数据集
rawdata <- read.csv('F://Coding/R/MNL/data/demoR.csv')
print(rawdata)
fit <- multinom(choice ~ l + a + b, data = rawdata)
print(fit)
# 直接使用multinom进行多项logit回归分析
# 其实mlogit和multinom要求的数据格式一致，也类似于pylogit要求的格式。
# 而mlogit进行数据重塑前的数据反而较为复杂。
library(nnet)
library(splines)
# 1.1利用multinom进行基于相应的数据格式进行多项logit回归
# 导入常规数据集
rawdata <- read.csv('F://Coding/R/MNL/data/demoR.csv')
print(rawdata)
fit <- multinom(choice ~ l + a + b, data = rawdata)
print(fit)
coef(fit)
# 1.2根据上述回归系数进行基于原数据的概率验证
# 导入线性回归数据集，使用原数据的色彩值进行效用验证
lmdata <- read.csv('F://Coding/R/MNL/data/demolm.csv')
print(lmdata)
# 计算效用值
u_exam <- coef(fit)[2] * lmdata$l + coef(fit)[3] * lmdata$a + coef(fit)[4] * lmdata$b + coef(fit)[1]
print(u_exam)
# 转换为概率值
pr <- exp(u_exam)
print(pr)
# 对概率进行归一化处理
pr <- pr / sum(pr)
print(pr)
# 1.3色彩空间预测
# 对于线性的系数可以添加新数据进行预测,都处于线性空间
newdata <- expand.grid(l = seq(0, 100, 10), a = seq(-100, 100, 20), b = seq(-100, 100, 20))
print(newdata)
# 计算效用值
u <- coef(fit)[2] * newdata$l + coef(fit)[3] * newdata$a + coef(fit)[4] * newdata$b
u <- data.frame(u)
print(u) # 获得相应的效用值与LAB的关系，用以进行可视化
# 2.1创新点，利用偏好影响值计算各色彩方案概率，通过线性回归反推相关色彩属性变量系数，从而进行整个色彩空间的预测。
# 直接通过对概率进行LOGIT，然后对原色彩数据进行线性回归，选择最后一项最为基准参考。
fit_lm <- lm(logit_value ~ dl + da + db, data = lmdata)
print(fit_lm)
coef(fit_lm)
# 2.2根据上述回归系数通过原色彩数据计算效用值进行验证
u_examlm <- coef(fit_lm)[2] * lmdata$l + coef(fit_lm)[3] * lmdata$a + coef(fit_lm)[4] * lmdata$b + coef(fit_lm)[1]
print(u_examlm)
# 转换为概率值
pr_lm <- exp(u_examlm)
print(pr_lm)
# 对概率进行归一化处理
pr_lm <- pr_lm / sum(pr_lm)
print(pr_lm)
# 3.1对于1.1进行样条基展开，并进行多项logit回归以观测方案属性变量的非线性性
ns1 <- multinom(choice ~ ns(l, df=4, intercept=TRUE)+ns(a, df=4, intercept=TRUE)+ns(b, df=4, intercept=TRUE) , data = rawdata)
print(ns1)
coef(ns1)
# 3.2根据上述回归系数进行基于原数据的概率验证
# 记录各个样条基函数并计算各效用值
ns1l <- ns(lmdata$l, df=4, intercept = TRUE)
print(ns1l)
ns1l <- data.frame(ns1l)
ul = coef(ns1)[2] * ns1l$X1 + coef(ns1)[3] * ns1l$X2 + coef(ns1)[4] * ns1l$X3 + coef(ns1)[5] * ns1l$X4
ns1a <- ns(lmdata$a, df=4, intercept = TRUE)
ns1a <- data.frame(ns1a)
ua = coef(ns1)[6] * ns1a$X1 + coef(ns1)[7] * ns1a$X2 + coef(ns1)[8] * ns1a$X3 + coef(ns1)[9] * ns1a$X4
ns1b <- ns(lmdata$b, df=4, intercept = TRUE)
ns1b <- data.frame(ns1b)
ub = coef(ns1)[10] * ns1b$X1 + coef(ns1)[11] * ns1b$X2 + coef(ns1)[12] * ns1b$X3 + coef(ns1)[13] * ns1b$X4
# 计算总效用值
u_ns = ul + ua + ub + coef(ns1)[1]
print(u_ns)
# 转换为概率值
pr_ns <- exp(u_ns)
print(pr_ns)
# 对概率进行归一化处理
pr_ns <- pr_ns / sum(pr_ns)
print(pr_ns)
# # 4.1样条样本量不足，具有13个系数，但仅有5个样本，暂时无法进行线性回归。
# # 4.1样条样本量不足，具有13个系数，但仅有5个样本，暂时无法进行线性回归。
# ns2 <- lm(logit_value ~ ns(dl, df=4)+ns(da, df=4)+ns(db, df=4) , data = lmdata)
# # 结合系数利用上述新数据对样条计算效用值
# # 结合系数利用上述新数据对样条计算效用值
# # 注意，上述样条系数是关于原数据的样条，对于预测而言，应限制最值等于原数据最值进行拟合，保证空间的连续，而超出最值外的数据则是线性的。
# # 结合系数利用上述新数据对样条计算效用值
# # 注意，上述样条系数是关于原数据的样条，对于预测而言，应限制最值等于原数据最值进行拟合，保证空间的连续，而超出最值外的数据则是线性的。
# ns1l <- ns(newdata$l, df=4, intercept = TRUE)
# 2.1创新点，利用偏好影响值计算各色彩方案概率，通过线性回归反推相关色彩属性变量系数，从而进行整个色彩空间的预测。
# 直接通过对概率进行LOGIT，然后对原色彩数据进行线性回归，选择最后一项最为基准参考。
fit_lm <- lm(logit_value ~ dl + da + db, data = lmdata)
print(fit_lm)
summary(fit_lm)
summary(fit)
print(fit)
