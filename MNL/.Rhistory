# 导入数据集
rawdata <- read.csv('F://Coding/R/MNL/data/demoR2.csv')
print(rawdata)
# 数据集转换
mydata <- mlogit.data(rawdata, shape='wide', choice='choice', varying = 2:16)
print(mydata)
write.csv(mydata, file='F://Coding/python/Behance/pylogit/data/demoR.csv')
write.csv(mydata, file='F://Coding/python/Behance/pylogit/data/demoR.csv')
print(mydata)
# 使用multinom
summary(multinom(choice ~ l + a + b, data = mydata))
library(nnet)
library(splines)
# 导入数据集
rawdata <- read.csv('F://Coding/R/MNL/data/demoR2.csv')
print(rawdata)
summary(multinom(choice ~ l + a + b, data = mydata))
summary(multinom(choice ~ l + a + b, data = rawdata))
# 导入数据集
rawdata <- read.csv('F://Coding/R/MNL/data/demoR.csv')
print(rawdata)
summary(multinom(choice ~ l + a + b, data = rawdata))
# 直接使用multinom进行多项logit回归分析
# 其实mlogit和multinom要求的数据格式一致，也类似于pylogit要求的格式。
# 而mlogit进行数据重塑前的数据反而较为复杂。
library(nnet)
library(splines)
# 导入数据集
rawdata <- read.csv('F://Coding/R/MNL/data/demoR.csv')
print(rawdata)
summary(multinom(choice ~ l + a + b, data = rawdata))
# 导入线性回归数据集
lmdata <- read.csv('F://Coding/R/MNL/data/demolm.csv')
print(lmdata)
# 导入线性回归数据集
lmdata <- read.csv('F://Coding/R/MNL/data/demolm.csv')
print(lmdata)
summary(lm(logit_value ~ dl + da + db, data = lmdata))
summary(lm(logit_value ~ dl + da + db - 1, data = lmdata))
summary(lm(logit_value ~ dl + da + db, data = lmdata))
summary(multinom(choice ~ l + a + b, data = rawdata))
# 附加样条
ns1 <- multinom(choice ~ ns(l, df=4)+ns(a, df=4)+ns(b, df=4) , data = rawdata)
print(ns1)
# 附加样条
res <- multinom(choice ~ ns(l, df=4)+ns(a, df=4)+ns(b, df=4) , data = mydata)
summary(res)
print(mydata)
print(rawdata)
print(ns1)
ns2 <- lm(choice ~ ns(l, df=4)+ns(a, df=4)+ns(b, df=4) , data = lmdata)
print(ns2)
ns2 <- lm(choice ~ ns(dl, df=4)+ns(da, df=4)+ns(db, df=4) , data = lmdata)
# 附加样条
ns1 <- multinom(choice ~ ns(l, df=4)+ns(a, df=4)+ns(b, df=4) , data = rawdata)
print(ns1)
ns2 <- lm(logit_value ~ ns(dl, df=4)+ns(da, df=4)+ns(db, df=4) , data = lmdata)
print(ns2)
ns2 <- glm(logit_value ~ ns(dl, df=4)+ns(da, df=4)+ns(db, df=4) , data = lmdata)
print(ns2)
ns2 <- lm(logit_value ~ ns(dl, df=4)+ns(da, df=4)+ns(db, df=4) , data = lmdata)
print(ns2)
# 导入常规数据集
rawdata <- read.csv('F://Coding/R/MNL/data/demoR.csv')
print(rawdata)
summary(multinom(choice ~ l + a + b, data = rawdata))
# 导入线性回归数据集
lmdata <- read.csv('F://Coding/R/MNL/data/demolm.csv')
print(lmdata)
summary(lm(logit_value ~ dl + da + db, data = lmdata))
summary(multinom(choice ~ l + a + b, data = rawdata))
# 附加样条
ns1 <- lm(choice ~ ns(l, df=4)+ns(a, df=4)+ns(b, df=4) , data = rawdata)
print(ns1)
# 附加样条
ns1 <- multinom(choice ~ ns(l, df=4)+ns(a, df=4)+ns(b, df=4) , data = rawdata)
print(ns1)
ns2 <- lm(logit_value ~ ns(dl, df=4)+ns(da, df=4)+ns(db, df=4) , data = lmdata)
print(ns2)
ns2 <- multinom(logit_value ~ ns(dl, df=4)+ns(da, df=4)+ns(db, df=4) , data = lmdata)
print(ns2)
ns2 <- multinom(logit_value ~ ns(dl, df=4)+ns(da, df=4)+ns(db, df=4) , data = lmdata)
print(ns2)
ns2 <- lm(logit_value ~ ns(dl, df=4)+ns(da, df=4)+ns(db, df=4) , data = lmdata)
print(ns2)
ns2 <- lm(logit_value ~ ns(dl, df=4)+ns(da, df=4)+ns(db, df=4) , data = lmdata)
print(ns2)
ns2 <- lm(logit_value ~ ns(dl, df=2)+ns(da, df=2)+ns(db, df=2) , data = lmdata)
print(ns2)
test <- ns(X, df=4, intercept=TRUE)
print(test)
summary(fit)
print(rawdata)
fit <- multinom(choice ~ l + a + b, data = rawdata)
# 直接使用multinom进行多项logit回归分析
# 其实mlogit和multinom要求的数据格式一致，也类似于pylogit要求的格式。
# 而mlogit进行数据重塑前的数据反而较为复杂。
library(nnet)
library(splines)
# 导入常规数据集
rawdata <- read.csv('F://Coding/R/MNL/data/demoR.csv')
print(rawdata)
fit <- multinom(choice ~ l + a + b, data = rawdata)
summary(fit)
a0 <- seq(-100,100,len=101)
b0 <- seq(-100,100,len=101)
print(a0)
l0 <- seq(50, len=101)
print(l0)
l0 <- seq(50, 50, len=101)
print(l0)
print(newdata)
newdata <- expand.grid(l0, a0, b0)
print(newdata)
a0 <- seq(-100,100,len=101)
print(a0)
b0 <- seq(-100,100,len=101)
l0 <- seq(50, 50, len=101)
print(l0)
newdata <- expand.grid(l0, a0, b0)
print(newdata)
newdata <- data.frame(l0, a0, b0)
print(newdata)
newdata <- expand.grid(l0, a0, b0)
print(newdata)
newdata <- expand.grid(l0 = 50, a0 = seq(-100, 100, 5), b0 = seq(-100, 100, 5))
print(newdata)
u <- predict(fit, newdata)
newdata <- expand.grid(l = 50, a = seq(-100, 100, 5), b = seq(-100, 100, 5))
print(newdata)
u <- predict(fit, newdata)
print(u)
print(fit.model)
summary(fit)
print(fit.model)
# 导入线性回归数据集
lmdata <- read.csv('F://Coding/R/MNL/data/demolm.csv')
print(lmdata)
summary(lm(logit_value ~ dl + da + db, data = lmdata))
ml <- read.dta("F://Coding/R/MNL/data/hsbdemo.dta")
print(ml)
require(foreign)
require(nnet)
require(ggplot2)
require(reshape2)
ml <- read.dta("F://Coding/R/MNL/data/hsbdemo.dta")
print(ml)
with(ml, table(ses, prog))
test <- multinom(prog2 ~ read + write + math, data = ml)
ml$prog2 <- relevel(ml$prog, ref = "academic")
test <- multinom(prog2 ~ read + write + math, data = ml)
summary(test)
# 构建相应的效用函数并进行回归计算
f <- mFormula(choice ~ l + a + b)
head(model.matrix(f, mydata), 5)
res <- mlogit(f, data=mydata)
summary(res)
library(mlogit)
library(nnet)
library(splines)
# 导入数据集
rawdata <- read.csv('F://Coding/R/MNL/data/demoR2.csv')
print(rawdata)
# 数据集转换
mydata <- mlogit.data(rawdata, shape='wide', choice='choice', varying = 2:16)
print(mydata)
# 构建相应的效用函数并进行回归计算
f <- mFormula(choice ~ l + a + b)
print(f)
head(model.matrix(f, mydata), 5)
res <- mlogit(f, data=mydata)
# 导入常规数据集
rawdata <- read.csv('F://Coding/R/MNL/data/demoR.csv')
print(rawdata)
fit <- multinom(choice ~ l + a + b, data = rawdata)
summary(fit)
newdata <- expand.grid(l = 50, a = seq(-100, 100, 5), b = seq(-100, 100, 5))
print(newdata)
u <- predict(fit, newdata)
print(u)
newdata <- expand.grid(l = 0, a = seq(-100, 100, 5), b = seq(-100, 100, 5))
print(newdata)
u <- predict(fit, newdata)
print(u)
summary(fit)
print(fitted.values())
print(fit.values())
str(sum)
print(sum$coeffients)
summary(fit)
summary(fit.coefficients)
sum.coefficients
sum = summary(fit)
print(sum)
print(sum.Call)
print(sum.call)
print(sum)
# 直接使用multinom进行多项logit回归分析
# 其实mlogit和multinom要求的数据格式一致，也类似于pylogit要求的格式。
# 而mlogit进行数据重塑前的数据反而较为复杂。
library(nnet)
library(splines)
# 导入常规数据集
rawdata <- read.csv('F://Coding/R/MNL/data/demoR.csv')
print(rawdata)
fit <- multinom(choice ~ l + a + b, data = rawdata)
sum = summary(fit)
print(sum)
newdata <- expand.grid(l = 0, a = seq(-100, 100, 5), b = seq(-100, 100, 5))
print(newdata)
u <- predict(fit, newdata)
print(u)
#
# 附加样条
ns1 <- multinom(choice ~ ns(l, df=4)+ns(a, df=4)+ns(b, df=4) , data = rawdata)
print(ns1)
print(fit)
print(fit.call)
print(fit["call"])
print(fit$coefficients)
print(fit$Coefficients)
print(fit[Coefficients])
print(fit['Coefficients'])
coef(fit)
print(coe)
print(coe)
coef(fit)
fit[coefficients()]
fit[coefficients]
fit['coefficients']
coefficients(fit)
coef(fit)
print(a)
coef(fit.l)
coef(fit).l
coef(fit)
coef(fit)[1]
coef(fit)[2]
type(coef(fit))
class(coef(fit))
coef(fit)['l']
coef(fit)['l'][1]
coef(fit)['l']*2
coef(fit)
calss(fit)
class(fit)
mode(fit)
fit$coefficients
fit$coefficients[2]
coef(fit)
#
# 附加样条
ns1 <- multinom(choice ~ ns(l, df=4)+ns(a, df=4)+ns(b, df=4) , data = rawdata)
print(ns1)
#
# 附加样条
ns1 <- multinom(choice ~ ns(l, df=4, intercept=TRUE)+ns(a, df=4, intercept=TRUE)+ns(b, df=4, intercept=TRUE) , data = rawdata)
print(ns1)
require(splines)
X <- c(1,2,3)
print(X)
test <- ns(X, df=4, intercept=TRUE)
print(test)
print(ns1)
u2 <- predict(ns1, newdata)
print(u2)
print(rawdata)
f <- multinom(y ~ l + a + b)
coef(fit)
print(newdata)
coef(fit)
print(newdata)
u <- coef(fit)[0] + coef(fit)[1] * newdata$l + coef(fit)[2] * newdata$a + coef(fit)[3] * newdata$b
print(u)
xx = coef(fit)[1]
print(xx)
nbb = xx * seq(1, 10, 1)
print(nbb)
print(newdata$l)
newdata <- expand.grid(l = 10, a = seq(-100, 100, 5), b = seq(-100, 100, 5))
print(newdata)
xx = coef(fit)[1]
print(xx)
nbb = xx * seq(1, 10, 1)
print(nbb)
print(newdata$l)
print(newdata)
nbb = coef(fit)[1] * seq(1, 10, 1)
print(nbb)
print(newdata$l)
u <- coef(fit)[0] + coef(fit)[1] * newdata$l + coef(fit)[2] * newdata$a + coef(fit)[3] * newdata$b
print(u)
u = coef(fit)[0] + coef(fit)[1] * newdata$l + coef(fit)[2] * newdata$a + coef(fit)[3] * newdata$b
print(u)
nbb = coef(fit)[1] * newdata$l
print(nbb)
u = coef(fit)[1] * newdata$l + coef(fit)[2] * newdata$a + coef(fit)[3] * newdata$b
print(u)
u = coef(fit)[0] + (coef(fit)[1] * newdata$l + coef(fit)[2] * newdata$a + coef(fit)[3] * newdata$b)
print(u)
coe = c(1,2,3)
class(coe)
coe = seq(1,2,3)
class(coe)
coe = vector(1,2,3)
coe = seq(coef(fit))
print(coe)
coe = seq(coef(fit)[0])
print(coe)
coe = coef(fit)[0]
print(coe)
coe <- coef(fit)[0]
print(coe)
coef(fit)[0]
fit <- multinom(choice ~ l + a + b, data = rawdata)
coef(fit)
coe <- seq(coef(fit))
print(coe)
coe <- seq(coef(fit)[0])
print(coe)
coef(fit)[0]
nbb = coef(fit)[1] * newdata$l
print(nbb)
coef(fit)[1]
u = coef(fit)[1] + (coef(fit)[2] * newdata$l + coef(fit)[3] * newdata$a + coef(fit)[4] * newdata$b)
print(u)
u = coef(fit)[1] + coef(fit)[2] * newdata$l + coef(fit)[3] * newdata$a + coef(fit)[4] * newdata$b
print(u)
newdata <- expand.grid(l = 10, a = seq(-100, 100, 5), b = seq(-100, 100, 5))
print(newdata)
coef(fit)
u = coef(fit)[2] * newdata$l + coef(fit)[3] * newdata$a + coef(fit)[4] * newdata$b
print(u)
coef(fit)[1]
coef(fit)[2]
u = coef(fit)[2] * 10 + coef(fit)[3] * (-100) + coef(fit)[4] * (-100)
print(u)
coef(fit)
xxx = -0.0001748286 * 10 + 0.0116847265 * (-100) + 0.0162697489 * (-100)
print(xxx)
u = coef(fit)[2] * 10 + coef(fit)[3] * (-100) + coef(fit)[4] * (-100)
print(u)
u = coef(fit)[2] * newdata$l + coef(fit)[3] * newdata$a + coef(fit)[4] * newdata$b
print(u)
class(u)
class(newdata)
u <- data.frame(u)
class(u)
print(u)
uu <- coef(fit) * newdata
print(uu)
c <- data.frame(coef(fit))
print(c)
c <- data.frame(coef(fit)[1], coef(fit)[2], coef(fit)[3])
print(c)
c <- data.frame(coef(fit)[2], coef(fit)[3], coef(fit)[4])
print(c)
uu <- c * newdata
class(c)
u <- data.frame(u)
# 导入线性回归数据集
lmdata <- read.csv('F://Coding/R/MNL/data/demolm.csv')
# 添加新数据
newdata <- expand.grid(l = 10, a = seq(-100, 100, 5), b = seq(-100, 100, 5))
print(newdata)
# 计算效用值
u <- coef(fit)[2] * newdata$l + coef(fit)[3] * newdata$a + coef(fit)[4] * newdata$b
u <- data.frame(u)
print(u)
u <- data.frame(u)
print(u)
x <- unique(newdata$a)
y <- unique(newdata$b)
z <- matrix(u, nrow = length(y), ncol = length(x))
plot3d(newdata$a, newdata$b, u, type="s", size=0.5, lit=FALSE,xlab = "a",ylab="b",zlab = "utility")
surface3d(x,y,z,alpha=0.4, front="lines", back="lines")
require(rgl)
library(rgl)
plot3d(newdata$a, newdata$b, u, type="s", size=0.5, lit=FALSE,xlab = "a",ylab="b",zlab = "utility")
surface3d(x,y,z,alpha=0.4, front="lines", back="lines")
x <- unique(newdata$a)
y <- unique(newdata$b)
z <- matrix(u, nrow = length(y), ncol = length(x))
plot3d(newdata$a, newdata$b, u, type="s", size=0.5, lit=FALSE,xlab = "a",ylab="b",zlab = "utility")
surface3d(x,y,z,alpha=0.4, front="lines", back="lines")
movie3d(spin3d(axis=c(0,0,1),rpm=3),duration=10,fps=50)
library(magick)
movie3d(spin3d(axis=c(0,0,1),rpm=3),duration=10,fps=50)
x <- unique(newdata$a)
y <- unique(newdata$b)
z <- matrix(u, nrow = length(y), ncol = length(x))
plot3d(newdata$a, newdata$b, u, type="s", size=0.5, lit=FALSE,xlab = "a",ylab="b",zlab = "utility")
surface3d(x,y,z,alpha=0.4, front="lines", back="lines")
x <- unique(newdata$a)
y <- unique(newdata$b)
z <- matrix(u, nrow = length(y), ncol = length(x))
plot3d(newdata$a, newdata$b, u, type="s", size=0.5, lit=FALSE,xlab = "a",ylab="b",zlab = "utility")
surface3d(x,y,z,alpha=0.4, front="lines", back="lines")
movie3d(spin3d(axis=c(0,0,1),rpm=3),duration=10,fps=50)
print(u)
x <- newdata$a
y <- newdata$b
z <- u
persp(x, y, z, theta = 30, phi = 30,
expand = 0.5, col = drapecol(z))
#
# 附加样条
ns1 <- multinom(choice ~ ns(l, df=4, intercept=TRUE)+ns(a, df=4, intercept=TRUE)+ns(b, df=4, intercept=TRUE) , data = rawdata)
print(ns1)
print(test)
class(test)
test[1]
test[2]
test$1
test.1
test[4]
test[1][1]
test[2][1]
test[2][2]
test <- data.frame(test)
print(test)
require(splines)
X <- c(4,2,3)
print(X)
test <- ns(X, df=4, intercept=TRUE)
print(test)
test <- data.frame(test)
print(test)
require(splines)
X <- c(4,80,3)
print(X)
test <- ns(X, df=4, intercept=TRUE)
print(test)
coef(ns1)
# 结合系数利用上述新数据对样条计算效用值
ns1l <- ns(newdata$l, df=4, intercept = TRUE)
# 结合系数利用上述新数据对样条计算效用值
ns1l <- ns(newdata$a, df=4, intercept = TRUE)
ns1l <- data.frame(ns1l)
print(ns1l)
require(splines)
X <- c(80,80,80,80)
print(X)
test <- ns(X, df=4, intercept=TRUE)
predict(ns1, newdata)
predict(ns1, newdata).values
# 添加新数据
newdata <- expand.grid(l = seq(0, 100, 10), a = seq(-100, 100, 10), b = seq(-100, 100, 10))
print(newdata)
# 添加新数据
newdata <- expand.grid(l = seq(0, 100, 10), a = seq(-100, 100, 20), b = seq(-100, 100, 20))
print(newdata)
# 计算效用值
u <- coef(fit)[2] * newdata$l + coef(fit)[3] * newdata$a + coef(fit)[4] * newdata$b
u <- data.frame(u)
print(u)
test <- ns(X, df=4, intercept=TRUE)
require(splines)
X <- c(4,80,3)
print(X)
test <- ns(X, df=4, intercept=TRUE)
print(test)
require(splines)
test <- data.frame(test)
print(test)
# 附加样条
ns1 <- multinom(choice ~ ns(l, df=4, intercept=TRUE)+ns(a, df=4, intercept=TRUE)+ns(b, df=4, intercept=TRUE) , data = rawdata)
print(ns1)
coef(ns1)
coef(ns1)[1]
coef(ns1)[13]
coef(ns1)[2]
print(ns1l)
ns1a <- ns(newdata$a, df=4, intercept = TRUE)
ns1a <- data.frame(ns1a)
print(ns1a)
ns1b <- ns(newdata$b, df=4, intercept = TRUE)
ns1b <- data.frame(ns1b)
print(ns1b)
print(u1)
print(ul)
# 结合系数利用上述新数据对样条计算效用值
ns1l <- ns(newdata$l, df=4, intercept = TRUE)
ns1l <- data.frame(ns1l)
print(ns1l)
ul = coef(ns1)[2] * ns1l$X1 + coef(ns1)[3] * ns1l$X2 + coef(ns1)[4] * ns1l$X3 + coef(ns1)[5] * ns1l$X4
print(ul)
# 结合系数利用上述新数据对样条计算效用值
ns1l <- ns(newdata$l, df=4, intercept = TRUE)
ns1l <- data.frame(ns1l)
print(ns1l)
ul = coef(ns1)[2] * ns1l$X1 + coef(ns1)[3] * ns1l$X2 + coef(ns1)[4] * ns1l$X3 + coef(ns1)[5] * ns1l$X4
print(ul)
ns1a <- ns(newdata$a, df=4, intercept = TRUE)
ns1a <- data.frame(ns1a)
print(ns1a)
ua = coef(ns1)[6] * ns1a$X1 + coef(ns1)[7] * ns1a$X2 + coef(ns1)[8] * ns1a$X3 + coef(ns1)[9] * ns1a$X4
print(ua)
ns1b <- ns(newdata$b, df=4, intercept = TRUE)
ns1b <- data.frame(ns1b)
print(ns1b)
ub = coef(ns1)[10] * ns1b$X1 + coef(ns1)[11] * ns1b$X2 + coef(ns1)[12] * ns1b$X3 + coef(ns1)[13] * ns1b$X4
print(ub)
u_ns = ul + ua + ub
print(u_ns)
print(u)
print(u_ns)
predict(ns1, newdata)
u_ns = ul + ua + ub
u_ns = data.frame(u_ns)
print(u_ns)
print(u)
